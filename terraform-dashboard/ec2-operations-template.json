{
  "name": "EC2 Operations",
  "description": "Perform operations on EC2 instances with health checks and monitoring",
  "category": "Operations",
  "terraformCode": "# Data source for instance information\ndata \"aws_instance\" \"target\" {\n  instance_id = var.instance_id\n}\n\n# Local values for computed configurations\nlocals {\n  timestamp = formatdate(\"YYYY-MM-DD-hhmm\", timestamp())\n  instance_ip = data.aws_instance.target.public_ip != \"\" ? data.aws_instance.target.public_ip : data.aws_instance.target.private_ip\n  health_check_url = var.health_check_url != \"\" ? var.health_check_url : \"http://${local.instance_ip}:${var.health_check_port}${var.health_check_path}\"\n  destructive_operations = [\"terminate\", \"force_stop\"]\n  is_destructive = contains(local.destructive_operations, var.operation)\n  \n  common_tags = merge(\n    var.tags,\n    {\n      Environment = var.environment\n      Module      = \"ec2-operations\"\n      InstanceId  = var.instance_id\n      Operation   = var.operation\n      Timestamp   = local.timestamp\n    }\n  )\n}\n\n# CloudWatch Log Group for operation logs\nresource \"aws_cloudwatch_log_group\" \"operations\" {\n  count             = var.monitoring_enabled ? 1 : 0\n  name              = \"/aws/ec2/operations/${var.instance_id}\"\n  retention_in_days = var.log_retention_days\n  \n  tags = local.common_tags\n}\n\n# Pre-operation backup (for destructive operations)\nresource \"aws_ebs_snapshot\" \"pre_operation_backup\" {\n  count = var.backup_before_operation && local.is_destructive ? length(data.aws_instance.target.ebs_block_device) : 0\n  \n  volume_id   = data.aws_instance.target.ebs_block_device[count.index].volume_id\n  description = \"Pre-${var.operation} backup for ${var.instance_id} - ${local.timestamp}\"\n  \n  tags = merge(\n    local.common_tags,\n    {\n      Name      = \"${var.instance_id}-pre-${var.operation}-backup\"\n      Purpose   = \"pre-operation-backup\"\n      VolumeId  = data.aws_instance.target.ebs_block_device[count.index].volume_id\n    }\n  )\n}\n\n# Pre-operation checks\nresource \"null_resource\" \"pre_operation_checks\" {\n  count = var.pre_operation_checks ? 1 : 0\n  \n  provisioner \"local-exec\" {\n    command = <<-EOT\n      echo \"Performing pre-operation checks for instance ${var.instance_id}...\"\n      \n      # Check instance state\n      current_state=$(aws ec2 describe-instances --instance-ids ${var.instance_id} --query 'Reservations[0].Instances[0].State.Name' --output text)\n      echo \"Current instance state: $current_state\"\n      \n      # Validate operation based on current state\n      case \"${var.operation}\" in\n        \"start\")\n          if [ \"$current_state\" != \"stopped\" ]; then\n            echo \"Warning: Instance is not in stopped state for start operation\"\n            ${var.force_operation ? \"echo 'Forcing operation...'\" : \"exit 1\"}\n          fi\n          ;;\n        \"stop\"|\"force_stop\")\n          if [ \"$current_state\" != \"running\" ]; then\n            echo \"Warning: Instance is not in running state for stop operation\"\n            ${var.force_operation ? \"echo 'Forcing operation...'\" : \"exit 1\"}\n          fi\n          ;;\n        \"restart\"|\"reboot\")\n          if [ \"$current_state\" != \"running\" ]; then\n            echo \"Warning: Instance is not in running state for restart operation\"\n            ${var.force_operation ? \"echo 'Forcing operation...'\" : \"exit 1\"}\n          fi\n          ;;\n      esac\n      \n      echo \"Pre-operation checks completed\"\n    EOT\n  }\n  \n  depends_on = [aws_ebs_snapshot.pre_operation_backup]\n}\n\n# Main operation execution\nresource \"null_resource\" \"operation_execution\" {\n  provisioner \"local-exec\" {\n    command = <<-EOT\n      echo \"Executing ${var.operation} operation on instance ${var.instance_id}...\"\n      echo \"Operation reason: ${var.operation_reason}\"\n      \n      ${var.dry_run ? \"echo 'DRY RUN: Would execute operation but dry_run is enabled'\" : \"\"}\n      \n      if [ \"${var.dry_run}\" = \"false\" ]; then\n        case \"${var.operation}\" in\n          \"start\")\n            aws ec2 start-instances --instance-ids ${var.instance_id}\n            ;;\n          \"stop\")\n            aws ec2 stop-instances --instance-ids ${var.instance_id}\n            ;;\n          \"force_stop\")\n            aws ec2 stop-instances --instance-ids ${var.instance_id} --force\n            ;;\n          \"restart\"|\"reboot\")\n            aws ec2 reboot-instances --instance-ids ${var.instance_id}\n            ;;\n          \"terminate\")\n            aws ec2 terminate-instances --instance-ids ${var.instance_id}\n            ;;\n          \"status\")\n            aws ec2 describe-instances --instance-ids ${var.instance_id} --query 'Reservations[0].Instances[0].State'\n            ;;\n          \"health_check\")\n            echo \"Performing health check...\"\n            ;;\n          \"wait_for_running\")\n            aws ec2 wait instance-running --instance-ids ${var.instance_id}\n            ;;\n          \"wait_for_stopped\")\n            aws ec2 wait instance-stopped --instance-ids ${var.instance_id}\n            ;;\n        esac\n      fi\n      \n      echo \"Operation ${var.operation} completed\"\n    EOT\n  }\n  \n  depends_on = [null_resource.pre_operation_checks]\n}\n\n# Wait for operation completion\nresource \"null_resource\" \"wait_for_completion\" {\n  count = var.wait_for_completion ? 1 : 0\n  \n  provisioner \"local-exec\" {\n    command = <<-EOT\n      echo \"Waiting for operation to complete...\"\n      timeout ${var.timeout_minutes * 60} bash -c '\n        while true; do\n          state=$(aws ec2 describe-instances --instance-ids ${var.instance_id} --query \"Reservations[0].Instances[0].State.Name\" --output text)\n          echo \"Current state: $state\"\n          \n          case \"${var.operation}\" in\n            \"start\"|\"restart\"|\"reboot\")\n              if [ \"$state\" = \"running\" ]; then\n                echo \"Instance is now running\"\n                break\n              fi\n              ;;\n            \"stop\"|\"force_stop\")\n              if [ \"$state\" = \"stopped\" ]; then\n                echo \"Instance is now stopped\"\n                break\n              fi\n              ;;\n            \"terminate\")\n              if [ \"$state\" = \"terminated\" ]; then\n                echo \"Instance is now terminated\"\n                break\n              fi\n              ;;\n            *)\n              echo \"Operation completed\"\n              break\n              ;;\n          esac\n          \n          sleep 10\n        done\n      '\n    EOT\n  }\n  \n  depends_on = [null_resource.operation_execution]\n}\n\n# Health checks\nresource \"null_resource\" \"health_checks\" {\n  count = var.health_check_enabled && contains([\"start\", \"restart\", \"reboot\"], var.operation) ? 1 : 0\n  \n  provisioner \"local-exec\" {\n    command = <<-EOT\n      echo \"Performing health checks...\"\n      \n      # HTTP health check\n      if [ \"${var.health_check_url}\" != \"\" ]; then\n        for i in $(seq 1 ${var.health_check_retries}); do\n          echo \"Health check attempt $i/${var.health_check_retries}\"\n          if curl -f -s --max-time ${var.health_check_timeout} \"${local.health_check_url}\" > /dev/null; then\n            echo \"HTTP health check passed\"\n            break\n          else\n            echo \"Health check failed, retrying...\"\n            sleep 10\n          fi\n          \n          if [ $i -eq ${var.health_check_retries} ]; then\n            echo \"All health check attempts failed\"\n            exit 1\n          fi\n        done\n      fi\n      \n      # SSH connectivity check\n      if [ \"${var.ssh_enabled}\" = \"true\" ] && [ \"${var.ssh_key_path}\" != \"\" ]; then\n        echo \"Testing SSH connectivity...\"\n        ssh -i \"${var.ssh_key_path}\" -o ConnectTimeout=${var.health_check_timeout} -o StrictHostKeyChecking=no ${var.ssh_user}@${local.instance_ip} \"echo 'SSH connection successful'\"\n      fi\n      \n      echo \"Health checks completed successfully\"\n    EOT\n  }\n  \n  depends_on = [null_resource.wait_for_completion]\n}\n\n# Post-operation checks\nresource \"null_resource\" \"post_operation_checks\" {\n  count = var.post_operation_checks ? 1 : 0\n  \n  provisioner \"local-exec\" {\n    command = <<-EOT\n      echo \"Performing post-operation checks...\"\n      \n      # Verify final state\n      final_state=$(aws ec2 describe-instances --instance-ids ${var.instance_id} --query 'Reservations[0].Instances[0].State.Name' --output text)\n      echo \"Final instance state: $final_state\"\n      \n      # Log operation completion\n      echo \"Operation ${var.operation} completed successfully at $(date)\"\n      echo \"Instance ${var.instance_id} is now in state: $final_state\"\n    EOT\n  }\n  \n  depends_on = [null_resource.health_checks]\n}",
  "variables": [
    {
      "name": "instance_id",
      "type": "string",
      "description": "ID of the EC2 instance to manage (i-xxxxxxxx)",
      "required": true
    },
    {
      "name": "operation",
      "type": "string",
      "description": "Operation to perform on the instance",
      "required": false,
      "default": "status",
      "options": [
        "status", "start", "stop", "restart", "reboot", 
        "terminate", "health_check", "wait_for_running", 
        "wait_for_stopped", "force_stop"
      ]
    },
    {
      "name": "wait_for_completion",
      "type": "boolean",
      "description": "Whether to wait for the operation to complete",
      "required": false,
      "default": true
    },
    {
      "name": "timeout_minutes",
      "type": "number",
      "description": "Timeout for operations in minutes",
      "required": false,
      "default": 10
    },
    {
      "name": "health_check_enabled",
      "type": "boolean",
      "description": "Enable health checks after operations",
      "required": false,
      "default": true
    },
    {
      "name": "health_check_url",
      "type": "string",
      "description": "URL for HTTP health checks (optional)",
      "required": false,
      "default": ""
    },
    {
      "name": "health_check_port",
      "type": "number",
      "description": "Port for health checks",
      "required": false,
      "default": 80
    },
    {
      "name": "health_check_path",
      "type": "string",
      "description": "Path for HTTP health checks",
      "required": false,
      "default": "/"
    },
    {
      "name": "health_check_timeout",
      "type": "number",
      "description": "Timeout for health checks in seconds",
      "required": false,
      "default": 30
    },
    {
      "name": "health_check_retries",
      "type": "number",
      "description": "Number of health check retries",
      "required": false,
      "default": 5
    },
    {
      "name": "ssh_enabled",
      "type": "boolean",
      "description": "Enable SSH connectivity checks",
      "required": false,
      "default": false
    },
    {
      "name": "ssh_user",
      "type": "string",
      "description": "SSH user for connectivity checks",
      "required": false,
      "default": "ec2-user",
      "options": ["ec2-user", "ubuntu", "admin", "root"]
    },
    {
      "name": "ssh_port",
      "type": "number",
      "description": "SSH port for connectivity checks",
      "required": false,
      "default": 22
    },
    {
      "name": "ssh_key_path",
      "type": "string",
      "description": "Path to SSH private key",
      "required": false,
      "default": ""
    },
    {
      "name": "force_operation",
      "type": "boolean",
      "description": "Force the operation even if instance is in unexpected state",
      "required": false,
      "default": false
    },
    {
      "name": "pre_operation_checks",
      "type": "boolean",
      "description": "Enable pre-operation validation checks",
      "required": false,
      "default": true
    },
    {
      "name": "post_operation_checks",
      "type": "boolean",
      "description": "Enable post-operation validation checks",
      "required": false,
      "default": true
    },
    {
      "name": "backup_before_operation",
      "type": "boolean",
      "description": "Create EBS snapshots before destructive operations",
      "required": false,
      "default": false
    },
    {
      "name": "operation_reason",
      "type": "string",
      "description": "Reason for performing the operation (for logging)",
      "required": false,
      "default": "Automated operation via Terraform Dashboard"
    },
    {
      "name": "dry_run",
      "type": "boolean",
      "description": "Perform a dry run without executing the actual operation",
      "required": false,
      "default": false
    },
    {
      "name": "monitoring_enabled",
      "type": "boolean",
      "description": "Enable CloudWatch monitoring during operations",
      "required": false,
      "default": true
    },
    {
      "name": "log_retention_days",
      "type": "number",
      "description": "CloudWatch log retention in days",
      "required": false,
      "default": 7,
      "options": [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365]
    }
  ]
}
